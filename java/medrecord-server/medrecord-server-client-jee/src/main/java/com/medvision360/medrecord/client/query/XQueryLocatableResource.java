// WARNING, THIS FILE IS AUTOMATICALLY GENERATED
// DO NOT MODIFY !

package com.medvision360.medrecord.client.query;

import org.restlet.Client;
import org.restlet.data.Language;
import org.restlet.data.Preference;
import org.restlet.resource.ClientResource;
import org.restlet.resource.ResourceException;

import com.medvision360.lib.client.ClientResourceBase;
import com.medvision360.lib.client.ClientResourceConfig;
import com.medvision360.lib.client.ErrorDocument;
import com.medvision360.lib.common.exceptions.AnnotatedResourceException;
import com.medvision360.lib.common.exceptions.ApiException;

/**
    @apipath /query/xquery/locatable

 */
public class XQueryLocatableResource extends ClientResourceBase
{
    /**
     * Constructor.
     *
     * <p>This constructor can be used to create a new client for this resource.</p>
     *
     * @param config_ Configuration object containing the location of the server
     *   this resource sends requests to.
     */
    public XQueryLocatableResource(
        final ClientResourceConfig config_
    )
    {
        super(config_, "/query/xquery/locatable");
    }

    /**
       XQuery locatable resources.

Executes the provided XQuery against all XQuery-capable storage mechanisms for locatables on the server
(depending on the server configuration, some locatables may be stored in non-xquery-capable stores) and
returns the result.

XQuery is a powerful query language, and accordingly this API provides a very advanced and powerful query
mechanism, but it is important to realize that the trade-off in using it is that writing the queries and
interpreting the results may be harder, and that performance may be lower than for some of the simpler query
options.

Roughly the same queries as supported by <code>/query/xquery</code> are supported,
with one additional constraint: you must ensure that the results of your query are processable as a list
of locatable, that is, the result should have a structure like

<pre>
&lt;composition&gt;...&lt;/composition&gt;
&lt;composition&gt;...&lt;/composition&gt;
&lt;composition&gt;...&lt;/composition&gt;
...
</pre>

or perhaps

<pre>
&lt;content xsi:type="v1:OBSERVATION"&gt;...&lt;/content&gt;
&lt;content xsi:type="v1:OBSERVATION"&gt;...&lt;/content&gt;
&lt;content xsi:type="v1:OBSERVATION"&gt;...&lt;/content&gt;
...
</pre>

A good way to ensure this is the case is to do a specific query and then look for the nearest acceptable
ancestor. For example,

<pre>
declare default element namespace "http://schemas.openehr.org/v1";
(: look for all compositions that contain blood_pressure measurements :)
archetype_details/archetype_id/value/text()[contains(.,"blood_pressure")]/ancestor::*[self::composition]
</pre>

If you do not specify a default element namespace in your query, it is set to "http://schemas.openehr.org/v1".
The xsi and openehr namespaces are also declared for you unless you have declared them yourself.



       <p>
       Use the {@link #locatableXQuery(String,XQueryLocatableResourceLocatableXQueryParams)}
       method to pass additional query arguments.</p>

       @param q An XQuery, written to run against (a) collection(s) that contains openEHR XML data and toreturn a list of xml fragments that can be parsed as locatables

       @apiqueryparam q An XQuery, written to run against (a) collection(s) that contains openEHR XML data and to
return a list of xml fragments that can be parsed as locatables
[type=string,required,single]
@apiqueryparam ehr An OpenEHR HierObjectID value specifying an EHR to search. Specify multiple times to search
multiple EHRs, or do not specify to search all EHRs. Note that the nature of combining XQuery and non-XQuery
constraints may mean that the OR-ing of this constraint with the XQuery constraint may not be very efficient
or performant, depending on the server storage implementation(s) in use.
[type=string,default=DC3BE110-DCF8-40C4-A8E3-AA1ADF78A959]



     */
    public org.restlet.representation.Representation locatableXQuery(
        final String q
    ) throws
        com.medvision360.medrecord.api.exceptions.InvalidQueryException,
        com.medvision360.medrecord.api.exceptions.UnsupportedQueryException,
        com.medvision360.medrecord.api.exceptions.RecordException,
        com.medvision360.medrecord.api.exceptions.IORecordException
    {
      return locatableXQuery(
        q,
        null
      );
    }

    /**
       XQuery locatable resources.

Executes the provided XQuery against all XQuery-capable storage mechanisms for locatables on the server
(depending on the server configuration, some locatables may be stored in non-xquery-capable stores) and
returns the result.

XQuery is a powerful query language, and accordingly this API provides a very advanced and powerful query
mechanism, but it is important to realize that the trade-off in using it is that writing the queries and
interpreting the results may be harder, and that performance may be lower than for some of the simpler query
options.

Roughly the same queries as supported by <code>/query/xquery</code> are supported,
with one additional constraint: you must ensure that the results of your query are processable as a list
of locatable, that is, the result should have a structure like

<pre>
&lt;composition&gt;...&lt;/composition&gt;
&lt;composition&gt;...&lt;/composition&gt;
&lt;composition&gt;...&lt;/composition&gt;
...
</pre>

or perhaps

<pre>
&lt;content xsi:type="v1:OBSERVATION"&gt;...&lt;/content&gt;
&lt;content xsi:type="v1:OBSERVATION"&gt;...&lt;/content&gt;
&lt;content xsi:type="v1:OBSERVATION"&gt;...&lt;/content&gt;
...
</pre>

A good way to ensure this is the case is to do a specific query and then look for the nearest acceptable
ancestor. For example,

<pre>
declare default element namespace "http://schemas.openehr.org/v1";
(: look for all compositions that contain blood_pressure measurements :)
archetype_details/archetype_id/value/text()[contains(.,"blood_pressure")]/ancestor::*[self::composition]
</pre>

If you do not specify a default element namespace in your query, it is set to "http://schemas.openehr.org/v1".
The xsi and openehr namespaces are also declared for you unless you have declared them yourself.



       @param queryParams_ The query parameters to be added to the request.
       @param q An XQuery, written to run against (a) collection(s) that contains openEHR XML data and toreturn a list of xml fragments that can be parsed as locatables

       @apiqueryparam q An XQuery, written to run against (a) collection(s) that contains openEHR XML data and to
return a list of xml fragments that can be parsed as locatables
[type=string,required,single]
@apiqueryparam ehr An OpenEHR HierObjectID value specifying an EHR to search. Specify multiple times to search
multiple EHRs, or do not specify to search all EHRs. Note that the nature of combining XQuery and non-XQuery
constraints may mean that the OR-ing of this constraint with the XQuery constraint may not be very efficient
or performant, depending on the server storage implementation(s) in use.
[type=string,default=DC3BE110-DCF8-40C4-A8E3-AA1ADF78A959]


     */
    public org.restlet.representation.Representation locatableXQuery(
        final String q,
        final XQueryLocatableResourceLocatableXQueryParams queryParams_
    ) throws
        com.medvision360.medrecord.api.exceptions.InvalidQueryException,
        com.medvision360.medrecord.api.exceptions.UnsupportedQueryException,
        com.medvision360.medrecord.api.exceptions.RecordException,
        com.medvision360.medrecord.api.exceptions.IORecordException
    {
        final ClientResource resource_ = getClientResource();
        try
        {
            if (queryParams_ != null)
            {
                queryParams_.applyTo(resource_);
            }

            resource_.addQueryParameter("q", q);
            final com.medvision360.medrecord.api.query.XQueryLocatableResource wrapped_ = resource_.wrap(com.medvision360.medrecord.api.query.XQueryLocatableResource.class);
            final org.restlet.representation.Representation result_ = wrapped_.locatableXQuery(
            );

            handleCookies(resource_);

            return result_;
        }
        catch(final ResourceException e_)
        {
            final ErrorDocument errorDocument_ = ErrorDocument.getFrom(resource_);
            if (errorDocument_ != null)
            {
                switch(errorDocument_.getCode())
                {
                    case "INVALID_QUERY_EXCEPTION":
                        throw new com.medvision360.medrecord.api.exceptions.InvalidQueryException(errorDocument_.getArguments());
                    case "UNSUPPORTED_QUERY_EXCEPTION":
                        throw new com.medvision360.medrecord.api.exceptions.UnsupportedQueryException(errorDocument_.getArguments());
                    case "RECORD_EXCEPTION":
                        throw new com.medvision360.medrecord.api.exceptions.RecordException(errorDocument_.getArguments());
                    case "IO_RECORD_EXCEPTION":
                        throw new com.medvision360.medrecord.api.exceptions.IORecordException(errorDocument_.getArguments());
                }
            }
            throw e_;
        }
    }

}
