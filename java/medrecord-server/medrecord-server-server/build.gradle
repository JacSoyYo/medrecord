apply plugin: 'medvision-server'

configurations {
  all*.exclude group:'commons-logging', module:'commons-logging'
}

dependencies {
  compile(project(":medrecord-engine")) {
    exclude group:'commons-logging', module:'commons-logging'
  }
  compile project(":medrecord-server-api-jee")
  compile(project(":medrecord-server-middleware")) {
    exclude group:'commons-logging', module:'commons-logging'
  }

  compile "ch.qos.logback:logback-classic:${ext.version.logback}"
  compile group: 'org.slf4j', name: 'slf4j-api', version:"${ext.version.slf4j}"
  compile group: 'org.slf4j', name: 'log4j-over-slf4j', version:"${ext.version.slf4j}"
  compile group: 'org.slf4j', name: 'jul-to-slf4j', version:"${ext.version.slf4j}"
  compile group: 'org.slf4j', name: 'jcl-over-slf4j', version:"${ext.version.slf4j}"

  testCompile "junit:junit:${ext.version.junit}"
  testCompile "org.restlet.jee:org.restlet.ext.httpclient:${ext.version.restlet}"
  testCompile project(":medrecord-server-client-jee")
  testCompile project(':medrecord-itest')
    

  // the artifact containing the swagger docs
  swagger project(path: ":medrecord-server-api-jee", configuration: "swaggerArtifacts")
  swagger "com.medvision360.lib.web:swagger:+:swaggerTool@zip"

    //jsonSchema project(path: ":medrecord-server-api-jee", configuration: "jsonSchemaArtifacts")
}

prepareTomcat {
  // TODO: make sure a special logback config is added to the debian package
  logbackConfig = project.file("logback-test.xml")
}

tomcatRunWar {
  httpPort = 8100
  stopPort = 8101
}

// merge the old middleware into this server, and add in custom config
// https://github.com/wadahiro/gradle-samples/blob/master/war-samples/merge-war-sample/build.gradle
import org.apache.tools.ant.filters.ReplaceTokens

// apply medvision-server plugin standard filter to local webapp resources
task filterLocalWarResources(type: Copy) {
  def displayName = project.ext.server.displayName
  def applicationClass = project.ext.server.applicationClass
  def projectId = project.ext.server.projectId

  from project.webAppDirName
  into new File(project.buildDir, "filtered")
  filter(
    ReplaceTokens,
    tokens:[
      displayName: displayName,
      servletName: project.group + '.' + project.name,
      applicationClass: applicationClass,
      agent: displayName + '/' + project.version,
      configfile: '/etc/medvision360/' + projectId + '/configuration.properties',
      version: project.version
    ]
  )
}

// disable merging in the middleware
//war.dependsOn(':medrecord-server-middleware:war')
war.dependsOn filterLocalWarResources
war << {
//  // add middleware but don't override anything
//  ant.zip(destfile: war.archivePath, update: true, keepcompression: true, duplicate: 'preserve') {
//    zipfileset (src: project(':medrecord-server-middleware').war.archivePath)
//  }
    
  // add our own local webapp stuff, do override
  // http://stackoverflow.com/questions/2210041/updating-files-inside-an-existing-war-file
  ant.touch {
    fileset(dir: "$project.buildDir/filtered")
  }
  ant.zip(destfile: war.archivePath, update: true, keepcompression: true, duplicate: 'add') {
    fileset(dir: "$project.buildDir/filtered")
  }
}

import org.gradle.plugins.ide.idea.model.*
apply plugin: 'idea'

idea.module.iml {
    whenMerged { module ->
        
        // add module dependencies for medvision common libraries
        def toModuleDependencies = [
                'libs-api-jee',
                'libs-client-jee',
                'libs-common-jee',
                'libs-server'
        ]
        
        toModuleDependencies.each { dependencyName ->
            module.dependencies += new ModuleDependency(dependencyName, 'COMPILE')
        }

        // split dependencies into module dependencies and jar dependencies
        def moduleDependencies = []
        module.dependencies.each { dependency ->
            if (dependency.class.simpleName == 'ModuleDependency') {
                if (dependency.scope.equalsIgnoreCase("COMPILE")) {
                    moduleDependencies += dependency
                }
            }
        }

        module.dependencies.removeAll(moduleDependencies)
        def jarDependencies = new LinkedHashSet(module.dependencies)

        module.dependencies.clear()
        module.dependencies.addAll(moduleDependencies)
        module.dependencies.addAll(jarDependencies)
    }
}
